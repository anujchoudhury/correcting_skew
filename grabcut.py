# import numpy as np
# import cv2 as cv
# from matplotlib import pyplot as plt
# img = cv.imread('/Users/anuj/Downloads/archive/intact/side/0707979392424_side.png')
# mask = np.zeros(img.shape[:2],np.uint8)
# bgdModel = np.zeros((1,65),np.float64)
# fgdModel = np.zeros((1,65),np.float64)
# rect = (50,50,450,290)
# cv.grabCut(img,mask,rect,bgdModel,fgdModel,5,cv.GC_INIT_WITH_RECT)
# mask2 = np.where((mask==2)|(mask==0),0,1).astype('uint8')
# img = img*mask2[:,:,np.newaxis]
# plt.imshow(img),plt.colorbar(),plt.show()

# Python program to illustrate
# foreground extraction using
# GrabCut algorithm

# organize imports
import numpy as np
import cv2
from matplotlib import pyplot as plt
import numpy as np
import argparse
import time
import cv2
import os
# path to input image specified and
# image is loaded with imread command
image = cv2.imread('/Users/anuj/Downloads/archive/intact/side/0707979392424_side.png')
mask = np.zeros(image.shape[:2], dtype="uint8")
rect = (495, 148, 300, 250)
plt.imshow(image)
plt.colorbar()
plt.show()

# allocate memory for two arrays that the GrabCut algorithm internally
# uses when segmenting the foreground from the background
fgModel = np.zeros((1, 65), dtype="float")
bgModel = np.zeros((1, 65), dtype="float")
# apply GrabCut using the the bounding box segmentation method
start = time.time()
(mask, bgModel, fgModel) = cv2.grabCut(image, mask, rect, bgModel,
	fgModel, 10, mode=cv2.GC_INIT_WITH_RECT)
end = time.time()
print("[INFO] applying GrabCut took {:.2f} seconds".format(end - start))

# the output mask has for possible output values, marking each pixel
# in the mask as (1) definite background, (2) definite foreground,
# (3) probable background, and (4) probable foreground
values = (
	("Definite Background", cv2.GC_BGD),
	("Probable Background", cv2.GC_PR_BGD),
	("Definite Foreground", cv2.GC_FGD),
	("Probable Foreground", cv2.GC_PR_FGD),
)
# loop over the possible GrabCut mask values
for (name, value) in values:
	# construct a mask that for the current value
	print("[INFO] showing mask for '{}'".format(name))
	valueMask = (mask == value).astype("uint8") * 255
	# display the mask so we can visualize it
	cv2.imshow(name, valueMask)
	cv2.waitKey(0)

# we'll set all definite background and probable background pixels
# to 0 while definite foreground and probable foreground pixels are
# set to 1
outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD),
	0, 1)
# scale the mask from the range [0, 1] to [0, 255]
outputMask = (outputMask * 255).astype("uint8")
# apply a bitwise AND to the image using our mask generated by
# GrabCut to generate our final output image
output = cv2.bitwise_and(image, image, mask=outputMask)

# show the input image followed by the mask and output generated by
# GrabCut and bitwise masking
cv2.imshow("Input", image)
cv2.imshow("GrabCut Mask", outputMask)
cv2.imshow("GrabCut Output", output)
cv2.waitKey(0)






# # create a simple mask image similar
# # to the loaded image, with the
# # shape and return type
# print(image.shape[:2])
# mask = np.zeros(image.shape[:2], np.uint8)

# # specify the background and foreground model
# # using numpy the array is constructed of 1 row
# # and 65 columns, and all array elements are 0
# # Data type for the array is np.float64 (default)
# backgroundModel = np.zeros((1, 65), np.float64)
# foregroundModel = np.zeros((1, 65), np.float64)

# # define the Region of Interest (ROI)
# # as the coordinates of the rectangle
# # where the values are entered as
# # (startingPoint_x, startingPoint_y, width, height)
# # these coordinates are according to the input image
# # it may vary for different images
# rectangle = (495, 148, 300, 150)

# # apply the grabcut algorithm with appropriate
# # values as parameters, number of iterations = 3
# # cv2.GC_INIT_WITH_RECT is used because
# # of the rectangle mode is used
# cv2.grabCut(image, mask, rectangle,
# 			backgroundModel, foregroundModel,
# 			3, cv2.GC_INIT_WITH_RECT)

# # In the new mask image, pixels will
# # be marked with four flags
# # four flags denote the background / foreground
# # mask is changed, all the 0 and 2 pixels
# # are converted to the background
# # mask is changed, all the 1 and 3 pixels
# # are now the part of the foreground
# # the return type is also mentioned,
# # this gives us the final mask
# mask2 = np.where((mask == 2)|(mask == 0), 0, 1).astype('uint8')

# # The final mask is multiplied with
# # the input image to give the segmented image.
# image = image * mask2[:, :, np.newaxis]

# # output segmented image with colorbar
# plt.imshow(image)
# plt.colorbar()
# plt.show()
